-- < 집합 연산자(SET OPERATOR) >
-- : 하나의 쿼리문 안에 여러개의 쿼리가 들어가는 형태를 가지는 연산자로써 테이블의 데이터를 하나로 합칠 때 주로 사용됨

-- UNION(합집합) : 두 개의 쿼리문에 대한 수행 결과를 더하고 중복 제거
-- EMPLOYEES 테이블에서 DEPARTMENT_ID가 80이면서 SALARY가 10000 이상인 직원 조회 (첫번째 쿼리문과 두번째 쿼리문을 이어 붙인다. 순서X)
SELECT
	EMPLOYEE_ID,
	FIRST_NAME,
	SALARY,
	DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE DEPARTMENT_ID = 80
UNION 
SELECT
	EMPLOYEE_ID,
	FIRST_NAME,
	SALARY,
	DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE SALARY >= 10000;

-- EMPLOYEES 테이블과 DEPARTMENTS 테이블의 데이터 결과를 합치고 중복 제거
SELECT
	FIRST_NAME,
	LAST_NAME,
	MANAGER_ID
FROM
	EMPLOYEES e
UNION
SELECT
	DEPARTMENT_NAME,
	to_char(LOCATION_ID), -- LOCATION_ID가 LAST_NAME 컬럼이 있는 공간으로 데이터를 합쳐야하기 때문에 데이터 타입을 맞춰줘야 함
	MANAGER_ID
FROM
	DEPARTMENTS d ;

-- UNION ALL(합집합 + 교집합) : UNION과 동작은 똑같지만 중복을 제거하지 않음
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e 
WHERE SALARY BETWEEN 5000 AND 10000
UNION ALL 
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e 
WHERE FIRST_NAME LIKE 'A%';

-- INTERSECT(교집합) : 두 개의 쿼리문에 대한 조건문이 부합한 데이터만 추출
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e 
WHERE SALARY BETWEEN 5000 AND 10000
INTERSECT 
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e 
WHERE FIRST_NAME LIKE 'A%';

-- MINUS(차집합) : 선행된 쿼리문의 수행 결과에서 후행 쿼리문의 결과값을 모두 제외한 데이터 추출
-- 첫번째 쿼리문의 조건은 만족하고 MINUS 이후의 쿼리문의 조건의 결과는 제외한 값 추출
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e 
WHERE SALARY BETWEEN 5000 AND 10000
MINUS  
SELECT FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES e 
WHERE FIRST_NAME LIKE 'A%';

-- <실습>-----------------------------
--1. EMPLOYEES 테이블에서 MANAGE_ID가 108이면서 월급이 8000 이상인 직원의
--	 데이터를 조회하되, 중복이 되는 값을 제거하고 조회 하세요
-- FIRST_NAME, LAST_NAME 컬럼을 이어 붙여서 수행 결과가 하나의 컬럼으로 나오도록 조회하세요.
SELECT FIRST_NAME || LAST_NAME FROM EMPLOYEES e 
WHERE MANAGER_ID = 108
UNION 
SELECT FIRST_NAME || LAST_NAME FROM EMPLOYEES e2 
WHERE SALARY >= 8000;

--2. EMPLOYEES와 DEPARTMENTS 테이블에서 DEPARTMENT_ID, MANAGER_ID가 중복
--   되는 데이터를 조회 하세요.
SELECT
	DEPARTMENT_ID,
	MANAGER_ID
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID IS NOT NULL
	AND MANAGER_ID IS NOT NULL 
INTERSECT 
SELECT
	DEPARTMENT_ID,
	MANAGER_ID
FROM
	DEPARTMENTS d
WHERE
	DEPARTMENT_ID IS NOT NULL
	AND MANAGER_ID IS NOT NULL;


-- < JOIN >
-- : 두 개 이상의 테이블의 데이터를 모두 조회할 때 사용하는 구문

-- INNER JOIN : 두 테이블의 공통된 컬럼의 값을 기준으로 집합을 반환함
-- 오라클 구문
SELECT
	e.DEPARTMENT_ID,
	e.FIRST_NAME,
	d.DEPARTMENT_NAME
FROM -- employees테이블 - e, department테이블-d
	EMPLOYEES e , DEPARTMENTS d
WHERE
	e.DEPARTMENT_ID = d.DEPARTMENT_ID; 

-- ANSI 구문
SELECT
	*
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d 
ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID;

-- LEFT OUTER JOIN : 왼쪽 테이블의 모든 행과, 오른쪽 테이블에서 일치하는 행들을 반환
-- 오라클 구문 (LEFT OUTER JOIN)
SELECT
	*
FROM
	EMPLOYEES e, DEPARTMENTS d
WHERE
	e.DEPARTMENT_ID = d.DEPARTMENT_ID(+);

-- ANSI 구문 (LEFT OUTER JOIN) 
SELECT * FROM EMPLOYEES e 
LEFT OUTER JOIN DEPARTMENTS d 
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;

-- RIGHT OUTER JOIN : 오른쪽 테이블의 모든 행과, 왼쪽 테이블에서 일치하는 행들을 반환
-- 오라클 구문 (RIGTH OUTER JOIN)
SELECT
	*
FROM
	EMPLOYEES e , DEPARTMENTS d
WHERE
	E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;

-- ANSI 구문 (RIGHT OUTER JOIN)
SELECT * FROM EMPLOYEES e 
RIGHT OUTER JOIN DEPARTMENTS d 
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;


-- FULL OUTER JOIN : 양쪽 테이블의 모든 행들을 반환
SELECT
	*
FROM
	EMPLOYEES e
FULL OUTER JOIN DEPARTMENTS d 
ON
	E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- EMPLOYEES 테이블, DEPARTMENT 테이블 (inner join : 일치하는 데이터만 추출)
-- 성(first) + 이름(last) + 부서명(department_name) 조회
SELECT
	FIRST_name,
	last_name,
	e.DEPARTMENT_ID,
	d.DEPARTMENT_ID,
	DEPARTMENT_NAME
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d 
ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID 



	
SELECT * FROM EMPLOYEES e ;
SELECT * FROM JOB_HISTORY jh ;

-- 직원이름, 근무시작일, 근무종료일	
SELECT
	FIRST_NAME,
	jh.START_DATE,
	jh.END_DATE
FROM
	EMPLOYEES e
JOIN JOB_HISTORY jh 
ON
	e.EMPLOYEE_ID = jh.EMPLOYEE_ID; 



-- department_id가 100인 직원의 이름과 부서명 조회
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME FROM EMPLOYEES e 
JOIN DEPARTMENTS d 
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
WHERE e.DEPARTMENT_ID = 100;


-- DEPARTMENT_ID가 80이고, 급여가 12000 이상인 직원의 이름과 부서 이름 조회
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME FROM EMPLOYEES e 
JOIN DEPARTMENTS d 
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
WHERE e.DEPARTMENT_ID = 80 AND e.SALARY >= 12000;


-- DEPARTMENT 테이블에서 LOCATION_ID를 기준으로 조인하여 각각의 부서 위치가
-- 어디인지(STREET_ADDRESS, CITY) 확인하기
-- 부서 위치 테이블 : LOCATIONS
-- 컬럼 조회 : DEPARTMENT_ID, STREET_ADDRESS, CITY
SELECT d.DEPARTMENT_ID, l.STREET_ADDRESS, l.CITY  FROM DEPARTMENTS d  
JOIN LOCATIONS l 
ON d.LOCATION_ID = l.LOCATION_ID 


-- EMPLOYEES 테이블에서 각각의 직원이 작업한 이력 확인하기
-- 작업 이력 테이블 : JOB_HISTORY
-- 컬럼 조회 : EMPLOYEE_ID, FIRST_NAME, START_DATE, END_DATE
SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, jh.START_DATE, jh.END_DATE FROM EMPLOYEES e 
JOIN JOB_HISTORY jh  
ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID  


-- * 여러 개의 테이블을 조인할 수 있음
-- 각각 직원들의 이름, 직무명, 작업이력
-- 직원들의 이름 : EMPLEYEES
-- 직무명 : JOBS
-- 작업이력 : JOB HISTORY
SELECT
	FIRST_NAME, j.JOB_TITLE, jh.START_DATE, jh.END_DATE 
FROM
	EMPLOYEES e
JOIN JOBS j ON
	e.JOB_ID = j.JOB_ID
JOIN JOB_HISTORY jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID ;


-- Q1. inner join 실습
-- 1. 직원의 이름, 이메일, 직무이름을 조회하세요.
-- EMPLOYEES, JOBS 테이블 조인 사용
SELECT FIRST_NAME, EMAIL, j.JOB_TITLE FROM EMPLOYEES e 
JOIN JOBS j ON e.JOB_ID = j.JOB_ID ;

-- 2. 직원의 이름, 속한 부서 이름, 직무, 근무 위치를 조회하세요.
-- EMPLOYYES, DEPARTMENT, JOBS, LOCATIONS
SELECT FIRST_NAME, d.DEPARTMENT_NAME, j.JOB_TITLE, l.CITY  FROM EMPLOYEES e
JOIN DEPARTMENTS d  ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
JOIN JOBS j ON e.JOB_ID = j.JOB_ID 
JOIN LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID ;

-- Q2. inner join + 조건식 실습
--1. 부서 이름이 ‘Sales’ 이거나 ‘Marketing’ 이고, 급여가 5000 이상인 직원 이름 조회
-- EMPLOYEES, DEPARTMENT 테이블
-- 부서 이름 : DEPARTMENT_NAME
-- 급여 : SALARY
SELECT FIRST_NAME FROM EMPLOYEES e
JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
WHERE DEPARTMENT_NAME IN('Sales', 'Marketing') AND e.SALARY >= 5000;

--2. 입사일이 2005년 6월 30일 이전인 직원의 직무명 조회
-- EMPLOYEES, JOBS 테이블
-- 입사일 : HIRE_DATE
-- 직무명 : JOB_TITLE
SELECT j.JOB_TITLE FROM EMPLOYEES e 
JOIN JOBS j ON e.JOB_ID = j.JOB_ID
WHERE e.HIRE_DATE <= '2005-06-30' ;

--3. 부서 이름이 ‘Shipping’ 이고, 이름이 7글자 이상인 직원의 아이디 조회
-- EMPLOYEES, DEPARTMENT 테이블
-- 부서 이름 : DEPARTMENT_NAME
-- 이름 : FIRST_NAME
-- 직원 아이디 : EMPLOYEE_ID
SELECT e.EMPLOYEE_ID, DEPARTMENT_NAME, FIRST_NAME FROM EMPLOYEES e 
JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
WHERE d.DEPARTMENT_NAME = 'Shipping' AND e.FIRST_NAME LIKE '_______%' 


-- 부서별 직원 수 조회 / 부서이름, 직원 수 출력
-- 부서이름 : department 테이블
-- 직원수 : EMPLOYEE 테이블 count
SELECT d.DEPARTMENT_ID, DEPARTMENT_NAME, count(*) FROM EMPLOYEES e
JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
GROUP BY DEPARTMENT_NAME, d.DEPARTMENT_ID  
HAVING count(*) >= 5;


-- 각 직무별로 평균 급여를 검색하고, 평균 급여가 가장 높은 직무의 이름과 평균 급여 출력하기
-- 급여 : EMPLOYEES 테이블
-- 직무 : JOBS 테이블
SELECT j.JOB_TITLE, AVG(SALARY) FROM EMPLOYEES e 
JOIN JOBS j ON e.JOB_ID = j.JOB_ID 
GROUP BY j.JOB_TITLE 
ORDER BY AVG(SALARY) DESC 
FETCH FIRST 10 ROW ONLY ; -- TOP N Query

















